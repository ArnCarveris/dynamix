# DynaMix
# Copyright (c) 2013-2018 Borislav Stanimirov, Zahary Karadjov
#
# Distributed under the MIT Software License
# See accompanying file LICENSE.txt or copy at
# https://opensource.org/licenses/MIT
#

# generates some mixins for the mutation performance tests

HEADER_FILE = 'generated.hpp'
COMPILE_FILE = 'generated.cpp'
NUM_MIXINS = 10

h_out = <<DATA
// DynaMix
// Copyright (c) 2013-2018 Borislav Stanimirov, Zahary Karadjov
//
// Distributed under the MIT Software License
// See accompanying file LICENSE.txt or copy at
// https://opensource.org/licenses/MIT
//
// this file is automatically generated by a script
DATA

c_out = h_out.clone

h_out += "#pragma once\n"

c_out += "#include \"common.hpp\"\n"
c_out += "#include \"#{HEADER_FILE}\"\n"
c_out += "using namespace dynamix;\n"

FDATA = [:type_templates, :mutators, :mixins]

class FileData
  FDATA.each do |sym|
    attr_accessor sym
  end

  def combine_data
    data = ''
    FDATA.each do |sym|
      data += "\n"
      data += send(sym)
    end
    data += "\n"

    data
  end
end

############################################################

H_MIXIN_ENTRY = <<DATA
DYNAMIX_MESSAGE_0(void, message_%{mixin_name});
DYNAMIX_DECLARE_MIXIN(%{mixin_name});
DATA

C_MIXIN_ENTRY = <<DATA

class %{mixin_name}
{
public:
  void message_%{mixin_name}() {}
  int %{members};
};
DYNAMIX_DEFINE_MIXIN(%{mixin_name}, message_%{mixin_name}_msg);
DYNAMIX_DEFINE_MESSAGE(message_%{mixin_name});
DATA

declare = FileData.new
define = FileData.new

declare.mixins = ''
define.mixins = ''

1.upto(NUM_MIXINS) do |i|
  params = {
    :mixin_name => "mixin_#{i}",
    :members => (1..i).map { |i| "a#{i}" }.join(', ')
  }

  declare.mixins += H_MIXIN_ENTRY % params
  define.mixins += C_MIXIN_ENTRY % params
end

############################################################

declare.type_templates = 'const std::vector<std::unique_ptr<dynamix::object_type_template>>& get_type_templates()'
define.type_templates = declare.type_templates.clone

declare.type_templates  += ";\n"
define.type_templates += "\n{\n"
define.type_templates += "  static std::vector<std::unique_ptr<dynamix::object_type_template>> v;\n"
define.type_templates += "  if (!v.empty()) return v;\n"
define.type_templates += "  v.reserve(1024);\n"

declare.mutators = 'const std::vector<void (*)(dynamix::object&)>& get_type_mutators()'
define.mutators = declare.mutators.clone

declare.mutators  += ";\n"
define.mutators += "\n{\n"
define.mutators += "  static std::vector<void (*)(dynamix::object&)> v;\n"
define.mutators += "  if (!v.empty()) return v;\n"
define.mutators += "  v.reserve(1024);\n"


C_TMPL_ENTRY = <<DATA
  {
    object_type_template* t = new object_type_template;

    t->
      %{adds}
      .create();

    v.emplace_back(t);
  }
DATA

C_MUT_ENTRY = <<DATA
  {
    auto mut = [](object& o)
    {
      mutate(o).
        %{adds};
    };
    v.emplace_back(mut);
  }
DATA

1.upto(NUM_MIXINS) do |i|
  (1..NUM_MIXINS).to_a.combination(i).each do |c|
    adds = c.map do |i|
      "add<mixin_#{i}>()"
    end

    params = { :adds => adds.join('.') }

    define.type_templates += C_TMPL_ENTRY % params
    define.mutators += C_MUT_ENTRY % params
  end
end

define.type_templates += "  return v;\n"
define.type_templates += "}"

define.mutators += "  return v;\n"
define.mutators += "}"

############################################################

h_out += declare.combine_data
c_out += define.combine_data

File.open(HEADER_FILE, "w").write(h_out)
File.open(COMPILE_FILE, "w").write(c_out)
